# 技术方案文章编写规则

## 文章定位

技术方案文章旨在帮助读者理解和实践某个技术方案、工具或方法。重点在于**清晰的原理解释**、**可操作的步骤**，以及**实际问题的解决**。

## 核心原则

### 1. 结构化与可读性并重
- ✅ 使用清晰的章节划分，方便读者快速定位
- ✅ 适当使用列表、代码块、图表来展示技术细节
- ✅ 保持逻辑的递进性（从问题到原理到实践）
- ❌ 避免过度简化导致缺乏深度
- ❌ 避免只有代码没有解释

**推荐结构：**
```
## 一、什么是 XXX？（问题背景）
用通俗语言解释概念，说明为什么需要这个技术...

## 二、核心原理（技术深度）
详细解释技术的工作原理，可以用列表、步骤分解...

## 三、实际操作（实践指导）
提供可复现的步骤、代码示例...

## 四、常见问题与案例（问题解决）
列举实际场景中的问题和解决方案...

## 五、总结与最佳实践
归纳要点，提供建议...
```

### 2. 由浅入深，照顾不同层次读者
- ✅ 开头用通俗类比解释复杂概念
- ✅ 核心章节提供技术深度
- ✅ 使用"小贴士"、"核心提示"等标注重要信息
- ✅ 提供延伸阅读链接
- ❌ 避免上来就抛专业术语
- ❌ 避免假设读者已经掌握某些前置知识

**示例：**
```
## 一、什么是 Git Rebase？

`git rebase` 是 Git 中用于**重新调整分支基准**的命令...

通俗来说：如果把分支开发比作"多条道路"，`merge` 是在道路交叉处
建一座"立交桥"（保留分叉），而 `rebase` 是将一条道路的终点直接
接到另一条道路的中间（消除分叉）。

> **小贴士：提升 Git 命令行效率**
> 如果你使用 Zsh，推荐安装 Oh My Zsh...
```

### 3. 代码和图表的恰当使用
- ✅ 代码块用于实际的命令、配置、代码示例
- ✅ 代码要有注释或后续解释
- ✅ 可以用代码块展示命令行输出、文件结构、对比示例
- ✅ 表格用于对比不同技术方案的特点
- ❌ 避免大段代码没有任何说明
- ❌ 避免代码示例不完整（无法运行）

**代码示例的标准格式：**
```
### 步骤 2：配置文件

创建 `xxx.config.ts` 文件：

```typescript
// 这里是代码示例
import { defineConfig } from 'xxx';

export default defineConfig({
  // 配置项说明
  option: 'value',
});
```

**说明**：
- `option` 参数用于控制 xxx 行为
- 如果需要 yyy 功能，可以添加...
```

### 4. 案例和问题驱动
- ✅ 用实际案例说明技术的应用场景
- ✅ 在"常见问题"章节解答真实痛点
- ✅ 提供完整的问题分析 → 解决方案流程
- ✅ 说明每种方案的适用场景
- ❌ 避免只讲理论不讲实践
- ❌ 避免案例脱离实际场景

**案例格式：**
```
### 案例 1：为什么 Rebase 后某些提交"消失"了？

**问题**：`feat/b` 分支有提交 `10c0c0a`，但 rebase 后消失了。

**原理**：`rebase` 会自动跳过**内容完全重复的提交**...

**解决方案**：无需处理，这是 Git 的自动优化。
```

### 5. 对比和最佳实践
- ✅ 对比不同技术方案的优缺点（适合用表格）
- ✅ 明确指出适用场景和不适用场景
- ✅ 提供"黄金法则"或"最佳实践"
- ✅ 警示常见的错误用法
- ❌ 避免只说"好"不说"坏"
- ❌ 避免缺少场景限定的建议

**对比示例（表格）：**
```
| 维度      | git rebase | git merge |
|-----------|------------|-----------|
| 历史记录  | 线性       | 保留分叉  |
| 适用场景  | 个人开发   | 团队协作  |
| 冲突处理  | 逐个解决   | 集中解决  |
```

### 6. 工具和诊断技巧
- ✅ 介绍相关的辅助工具和命令
- ✅ 提供问题排查的方法
- ✅ 说明如何验证操作是否成功
- ❌ 避免只讲"怎么做"不讲"怎么查"

**示例：**
```
## 四、问题排查工具

### 1. `git status`：你的当前状态顾问
在 Rebase 过程中，`git status` 会清晰地告诉你：
- 当前正处于 rebase 过程中
- 正在处理哪个提交
- 哪些文件存在冲突

### 2. `git reflog`：你的终极"后悔药"
记录了 HEAD 的每一次移动，如果搞砸了可以通过它恢复...
```

## 文章结构模板

### 开头（是什么 + 为什么）
- 简洁定义技术概念
- 用通俗类比帮助理解
- 说明解决的问题或应用场景
- 可选：与其他方案的对比

### 正文（怎么做）
- **原理章节**：深入解释技术的工作机制（可以分步骤、画图、用代码示例）
- **实践章节**：提供可操作的步骤、配置、代码
- **案例章节**：列举实际问题和解决方案

### 结尾（总结和建议）
- 归纳要点和核心价值
- 列出最佳实践或注意事项
- 提供延伸资源（文档、工具、相关文章）

## Frontmatter 格式

```yaml
---
title: "技术名称 + 技术类型（如：原理、实践指南、最佳实践）"
createDate: "YYYY-MM-DD"
updateDate: "YYYY-MM-DD"
tags:
  - 技术栈标签（如 Git、React、TypeScript）
  - 技术分类标签（如 版本控制、前端框架）
  - 不超过 5 个
author: "作者名"
excerpt: "一句话说明这篇文章帮助读者解决什么问题或学到什么。120 字以内。"
---
```

## 语言风格

- **专业但易懂**：使用准确的技术术语，但配合通俗解释
- **指令性语言**：使用"执行"、"运行"、"配置"等明确的动作词
- **结构化表达**：多用"首先...然后...最后..."这样的逻辑词
- **警示性提醒**：用"注意"、"重要"、"警告"标注关键信息

## 检查清单

- [ ] 是否用通俗语言解释了核心概念？
- [ ] 代码示例是否完整且可运行？
- [ ] 是否提供了问题排查的方法？
- [ ] 是否说明了适用场景和不适用场景？
- [ ] 表格和列表是否用在了合适的地方？
- [ ] 是否有实际案例支撑理论？
- [ ] 读者看完后能否独立实践？

## 特殊元素使用

### 引用块（> ）
用于突出重要提示、小贴士、注意事项：
```markdown
> **核心提示**：rebase 后的提交哈希值会改变，
> 这是"改写历史"的根本原因。
```

### 加粗（**）
用于强调关键术语、重要操作、核心概念：
```markdown
`rebase` 的本质是**"复制提交并重建历史"**
```

### 代码标记（`）
用于内联的命令、参数、文件名、配置项：
```markdown
执行 `git rebase --continue` 继续
```

## 参考示例

可以参考以下已发布的技术方案文章：
- `/posts/git-rebase/index.md` - Git Rebase 技术原理与实践指南
- `/posts/introducing-cogita.md` - Cogita 框架介绍（产品+技术）
